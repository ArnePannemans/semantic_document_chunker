<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chunk Validator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #f5f5f5;
        }

        .header {
            background: #fff;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #333;
        }

        .header-actions {
            display: flex;
            gap: 0.75rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #2563eb;
            color: white;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
        }

        .btn-secondary:hover {
            background: #e5e7eb;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .editor-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #fff;
            border-right: 1px solid #e0e0e0;
        }

        .editor {
            flex: 1;
            padding: 1.5rem;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            border: none;
            resize: none;
            outline: none;
            overflow-y: auto;
        }

        .dashboard-pane {
            width: 400px;
            background: #fff;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .dashboard-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .stats-section {
            margin-bottom: 1.5rem;
        }

        .stats-section h2 {
            font-size: 1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 1rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .stat-card {
            background: #f9fafb;
            padding: 0.75rem;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #6b7280;
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: #111827;
        }

        .rules-section {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .rule-input {
            flex: 1;
        }

        .rule-input label {
            display: block;
            font-size: 0.75rem;
            color: #6b7280;
            margin-bottom: 0.25rem;
        }

        .rule-input input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.875rem;
        }

        .chunks-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .chunk-item {
            padding: 0.75rem;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chunk-item:hover {
            background: #f3f4f6;
            border-color: #d1d5db;
        }

        .chunk-item.invalid {
            background: #fef2f2;
            border-color: #fca5a5;
        }

        .chunk-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .chunk-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
        }

        .chunk-title.invalid {
            color: #dc2626;
        }

        .chunk-warning {
            color: #dc2626;
            font-size: 0.875rem;
        }

        .chunk-stats {
            font-size: 0.75rem;
            color: #6b7280;
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1.5rem;
            color: #6b7280;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        .empty-state-text {
            font-size: 0.875rem;
        }

        .validation-status {
            padding: 0.75rem 1.5rem;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
        }

        .status-ok {
            color: #10b981;
            font-weight: 500;
        }

        .status-error {
            color: #dc2626;
            font-weight: 500;
        }

        .filename-display {
            font-size: 0.875rem;
            color: #6b7280;
            margin-left: 1rem;
        }

        .folder-select {
            padding: 0.375rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.875rem;
            background: white;
            cursor: pointer;
        }

        .folder-select:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }

        .file-browser {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 300px;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: none;
            flex-direction: column;
            z-index: 1000;
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
        }

        .file-browser.open {
            display: flex;
        }

        .file-browser-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-browser-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #333;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            padding: 0;
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: #111827;
        }

        .file-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .file-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.875rem;
            transition: all 0.2s;
            word-break: break-all;
        }

        .file-item:hover {
            background: #f3f4f6;
        }

        .file-item.active {
            background: #dbeafe;
            color: #1e40af;
            font-weight: 500;
        }

        .file-item.copied {
            border-left: 3px solid #10b981;
        }

        .file-item .copied-badge {
            color: #10b981;
            font-size: 0.75rem;
            margin-left: 0.5rem;
        }

        .toggle-browser-btn {
            position: fixed;
            left: 1rem;
            bottom: 1rem;
            padding: 0.75rem 1rem;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 999;
        }

        .toggle-browser-btn:hover {
            background: #f9fafb;
        }

        .split-marker {
            display: inline-block;
            background: #fbbf24;
            color: #92400e;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.875em;
            margin: 0 0.25rem;
            cursor: text;
        }

        .chunk-boundary {
            border-top: 2px solid #e5e7eb;
            margin: 1rem 0;
            padding-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <div style="display: flex; align-items: center; gap: 1rem;">
            <h1>Chunk Validator</h1>
            <div style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem;">
                <label style="color: #6b7280;">Source:</label>
                <select id="sourceFolder" class="folder-select"></select>
                <span style="color: #6b7280;">→</span>
                <label style="color: #6b7280;">Target:</label>
                <select id="targetFolder" class="folder-select"></select>
            </div>
            <span class="filename-display" id="filenameDisplay"></span>
        </div>
        <div class="header-actions">
            <button class="btn btn-secondary" onclick="previousFile()" id="prevBtn" disabled>← Prev</button>
            <button class="btn btn-secondary" onclick="nextFile()" id="nextBtn" disabled>Next →</button>
            <button class="btn btn-secondary" onclick="exportIterationPrompt()" id="exportPromptBtn" disabled>📋 Export Prompt</button>
            <button class="btn btn-success" id="saveBtn" onclick="saveFile()" disabled>Save</button>
        </div>
    </div>

    <div class="file-browser" id="fileBrowser">
        <div class="file-browser-header">
            <h3>Files</h3>
            <button class="close-btn" onclick="toggleFileBrowser()">×</button>
        </div>
        <div class="file-list" id="fileList"></div>
    </div>
    <button class="toggle-browser-btn" onclick="toggleFileBrowser()" id="toggleBrowserBtn">
        📁 Files
    </button>

    <div class="container">
        <div class="editor-pane">
            <div class="editor" id="editor" contenteditable="true" spellcheck="false"></div>
        </div>

        <div class="dashboard-pane">
            <div class="dashboard-content">
                <div class="stats-section">
                    <h2>Global Statistics</h2>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Total Chunks</div>
                            <div class="stat-value" id="totalChunks">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Avg Size</div>
                            <div class="stat-value" id="avgSize">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Min Size</div>
                            <div class="stat-value" id="minSize">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Max Size</div>
                            <div class="stat-value" id="maxSize">0</div>
                        </div>
                    </div>
                </div>

                <div class="stats-section">
                    <h2>Validation Rules</h2>
                    <div class="rules-section">
                        <div class="rule-input">
                            <label>Min Words</label>
                            <input type="number" id="minWords" value="100" min="1" />
                        </div>
                        <div class="rule-input">
                            <label>Max Words</label>
                            <input type="number" id="maxWords" value="270" min="1" />
                        </div>
                    </div>
                </div>

                <div class="stats-section">
                    <h2>Chunks</h2>
                    <div class="chunks-list" id="chunksList">
                        <div class="empty-state">
                            <div class="empty-state-icon">📄</div>
                            <div class="empty-state-text">No document loaded</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="validation-status" id="validationStatus">
                <span>Ready</span>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8001/api';

        let allFiles = [];
        let copiedFiles = new Set();
        let currentFileIndex = -1;
        let currentFilename = null;
        let rawContent = '';
        let availableFolders = [];

        const editor = document.getElementById('editor');
        const minWordsInput = document.getElementById('minWords');
        const maxWordsInput = document.getElementById('maxWords');
        const saveBtn = document.getElementById('saveBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const sourceFolderSelect = document.getElementById('sourceFolder');
        const targetFolderSelect = document.getElementById('targetFolder');

        // Real-time update on editor change
        editor.addEventListener('input', handleEditorInput);
        minWordsInput.addEventListener('input', analyzeDocument);
        maxWordsInput.addEventListener('input', analyzeDocument);
        sourceFolderSelect.addEventListener('change', onSourceFolderChange);
        targetFolderSelect.addEventListener('change', onTargetFolderChange);

        // Initialize
        async function init() {
            await loadFolders();
            await loadFileList();
            displayEmptyState();
        }

        async function loadFolders() {
            try {
                const response = await fetch(`${API_BASE}/folders`);
                const data = await response.json();
                availableFolders = data.folders;

                // Populate dropdowns
                sourceFolderSelect.innerHTML = availableFolders.map(f =>
                    `<option value="${f}">${f}</option>`
                ).join('');

                targetFolderSelect.innerHTML = availableFolders.map(f =>
                    `<option value="${f}">${f}</option>`
                ).join('');

                // Set defaults
                if (availableFolders.length >= 2) {
                    sourceFolderSelect.value = availableFolders[0];
                    targetFolderSelect.value = availableFolders[1];
                } else if (availableFolders.length === 1) {
                    sourceFolderSelect.value = availableFolders[0];
                    targetFolderSelect.value = availableFolders[0];
                }
            } catch (error) {
                console.error('Error loading folders:', error);
            }
        }

        async function onSourceFolderChange() {
            await loadFileList();
        }

        async function onTargetFolderChange() {
            await checkCopiedFiles();
            renderFileList();
        }

        async function loadFileList() {
            try {
                const sourceFolder = sourceFolderSelect.value;
                const response = await fetch(`${API_BASE}/files?folder=${encodeURIComponent(sourceFolder)}`);
                const data = await response.json();
                allFiles = data.files;
                await checkCopiedFiles();
                renderFileList();
            } catch (error) {
                console.error('Error loading file list:', error);
            }
        }

        async function checkCopiedFiles() {
            copiedFiles.clear();
            const targetFolder = targetFolderSelect.value;

            try {
                const response = await fetch(`${API_BASE}/copied-files?folder=${encodeURIComponent(targetFolder)}`);
                const data = await response.json();

                // Add all copied files to the Set
                data.files.forEach(filename => copiedFiles.add(filename));
            } catch (error) {
                console.error('Error checking copied files:', error);
            }
        }

        function renderFileList() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';

            allFiles.forEach((filename, index) => {
                const fileItem = document.createElement('div');
                const isCopied = copiedFiles.has(filename);
                fileItem.className = 'file-item' + (isCopied ? ' copied' : '');
                fileItem.innerHTML = filename + (isCopied ? '<span class="copied-badge">✓</span>' : '');
                fileItem.onclick = () => loadFileByIndex(index, true);
                fileList.appendChild(fileItem);
            });
        }

        async function loadFileByIndex(index, closeFileBrowser = false) {
            if (index < 0 || index >= allFiles.length) return;

            currentFileIndex = index;
            currentFilename = allFiles[index];

            try {
                const sourceFolder = sourceFolderSelect.value;
                const response = await fetch(`${API_BASE}/file/${currentFilename}?folder=${encodeURIComponent(sourceFolder)}`);
                const data = await response.json();
                rawContent = data.content;

                renderEditor();
                analyzeDocument();
                updateUI();

                if (closeFileBrowser) {
                    toggleFileBrowser();
                }
            } catch (error) {
                console.error('Error loading file:', error);
            }
        }

        function renderEditor() {
            // Convert <SPLIT> markers to visual elements
            const parts = rawContent.split(/(<SPLIT>)/gi);
            let html = '';

            for (let i = 0; i < parts.length; i++) {
                if (parts[i].match(/<SPLIT>/i)) {
                    html += '<span class="split-marker" contenteditable="false">&lt;SPLIT&gt;</span>';
                } else if (parts[i]) {
                    // Escape HTML but preserve line breaks
                    const escaped = parts[i]
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/\n/g, '<br>');
                    html += escaped;
                }
            }

            editor.innerHTML = html || '<span style="color: #9ca3af;">Load a file to begin...</span>';
            if (rawContent) {
                editor.focus();
            }
        }

        function handleEditorInput() {
            // Extract plain text from editor
            rawContent = getEditorText();
            analyzeDocument();
        }

        function getEditorText() {
            // Get text from contenteditable, preserving <SPLIT> markers
            let text = '';
            const nodes = editor.childNodes;

            for (let node of nodes) {
                if (node.nodeType === Node.TEXT_NODE) {
                    text += node.textContent;
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    if (node.classList && node.classList.contains('split-marker')) {
                        text += '<SPLIT>';
                    } else if (node.tagName === 'BR') {
                        text += '\n';
                    } else if (node.tagName === 'DIV') {
                        text += '\n' + node.textContent;
                    } else {
                        text += node.textContent;
                    }
                }
            }

            return text;
        }

        function countWords(text) {
            return text.trim().split(/\s+/).filter(word => word.length > 0).length;
        }

        function analyzeDocument() {
            const text = rawContent;
            const minWords = parseInt(minWordsInput.value) || 0;
            const maxWords = parseInt(maxWordsInput.value) || Infinity;

            // Split by <SPLIT> marker
            const chunks = text.split(/<SPLIT>/i).map(chunk => chunk.trim()).filter(chunk => chunk.length > 0);

            if (chunks.length === 0) {
                displayEmptyState();
                return;
            }

            // Calculate statistics
            const wordCounts = chunks.map(countWords);
            const totalChunks = chunks.length;
            const avgSize = Math.round(wordCounts.reduce((a, b) => a + b, 0) / totalChunks);
            const minSize = Math.min(...wordCounts);
            const maxSize = Math.max(...wordCounts);

            // Update global stats
            document.getElementById('totalChunks').textContent = totalChunks;
            document.getElementById('avgSize').textContent = avgSize;
            document.getElementById('minSize').textContent = minSize;
            document.getElementById('maxSize').textContent = maxSize;

            // Render chunks list
            const chunksList = document.getElementById('chunksList');
            chunksList.innerHTML = '';

            let invalidCount = 0;
            chunks.forEach((chunk, index) => {
                const wordCount = wordCounts[index];
                const isValid = wordCount >= minWords && wordCount <= maxWords;
                if (!isValid) invalidCount++;

                const chunkItem = document.createElement('div');
                chunkItem.className = 'chunk-item' + (isValid ? '' : ' invalid');
                chunkItem.innerHTML = `
                    <div class="chunk-header">
                        <span class="chunk-title ${isValid ? '' : 'invalid'}">Chunk ${index + 1}</span>
                        ${isValid ? '' : '<span class="chunk-warning">⚠️</span>'}
                    </div>
                    <div class="chunk-stats">${wordCount} words</div>
                `;
                chunksList.appendChild(chunkItem);
            });

            // Update validation status
            const statusEl = document.getElementById('validationStatus');
            if (invalidCount === 0) {
                statusEl.innerHTML = '<span class="status-ok">✓ All chunks valid</span>';
            } else {
                statusEl.innerHTML = `<span class="status-error">⚠️ ${invalidCount} invalid chunk${invalidCount > 1 ? 's' : ''}</span>`;
            }
        }

        function displayEmptyState() {
            document.getElementById('totalChunks').textContent = '0';
            document.getElementById('avgSize').textContent = '0';
            document.getElementById('minSize').textContent = '0';
            document.getElementById('maxSize').textContent = '0';

            const chunksList = document.getElementById('chunksList');
            chunksList.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">📄</div>
                    <div class="empty-state-text">No chunks detected</div>
                </div>
            `;

            const statusEl = document.getElementById('validationStatus');
            statusEl.innerHTML = '<span>Ready</span>';
        }

        async function saveFile() {
            if (!currentFilename) return;

            try {
                const sourceFolder = sourceFolderSelect.value;
                const targetFolder = targetFolderSelect.value;

                const response = await fetch(`${API_BASE}/file/${currentFilename}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        content: rawContent,
                        source_folder: sourceFolder,
                        target_folder: targetFolder
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Mark file as copied
                    copiedFiles.add(currentFilename);
                    renderFileList();

                    // Visual feedback
                    const originalText = saveBtn.textContent;
                    saveBtn.textContent = '✓ Saved';
                    saveBtn.classList.remove('btn-success');
                    saveBtn.classList.add('btn-secondary');

                    setTimeout(() => {
                        saveBtn.textContent = originalText;
                        saveBtn.classList.remove('btn-secondary');
                        saveBtn.classList.add('btn-success');
                    }, 1500);
                }
            } catch (error) {
                console.error('Error saving file:', error);
                alert('Error saving file');
            }
        }

        function previousFile() {
            if (currentFileIndex > 0) {
                loadFileByIndex(currentFileIndex - 1);
            }
        }

        function nextFile() {
            if (currentFileIndex < allFiles.length - 1) {
                loadFileByIndex(currentFileIndex + 1);
            }
        }

        function updateUI() {
            document.getElementById('filenameDisplay').textContent = currentFilename || '';
            saveBtn.disabled = !currentFilename;
            prevBtn.disabled = currentFileIndex <= 0;
            nextBtn.disabled = currentFileIndex >= allFiles.length - 1;
            document.getElementById('exportPromptBtn').disabled = !currentFilename;

            // Update file list active state
            const fileItems = document.querySelectorAll('.file-item');
            fileItems.forEach((item, index) => {
                item.classList.toggle('active', index === currentFileIndex);
            });
        }

        function toggleFileBrowser() {
            const browser = document.getElementById('fileBrowser');
            browser.classList.toggle('open');
        }

        async function exportIterationPrompt() {
            if (!currentFilename) return;

            const minWords = parseInt(minWordsInput.value) || 0;
            const maxWords = parseInt(maxWordsInput.value) || Infinity;

            // Calculate current statistics
            const chunks = rawContent.split(/<SPLIT>/i).map(chunk => chunk.trim()).filter(chunk => chunk.length > 0);
            const wordCounts = chunks.map(countWords);
            const totalChunks = chunks.length;
            const avgSize = Math.round(wordCounts.reduce((a, b) => a + b, 0) / totalChunks);
            const minSize = Math.min(...wordCounts);
            const maxSize = Math.max(...wordCounts);

            // Build detailed chunk statistics
            const chunkDetails = [];
            let invalidCount = 0;
            chunks.forEach((chunk, index) => {
                const wordCount = wordCounts[index];
                const isValid = wordCount >= minWords && wordCount <= maxWords;
                if (!isValid) invalidCount++;

                const preview = chunk.substring(0, 80).replace(/\n/g, ' ');
                chunkDetails.push({
                    index: index + 1,
                    wordCount: wordCount,
                    isValid: isValid,
                    status: isValid ? '✓' : (wordCount < minWords ? '⚠️ TOO SHORT' : '⚠️ TOO LONG'),
                    preview: preview + (chunk.length > 80 ? '...' : '')
                });
            });

            // Build the prompt
            const prompt = `# RAG Document Chunking - Iteration 2 Review

## Context

I'm building a training dataset for semantic document chunking optimized for Retrieval-Augmented Generation (RAG). In the first iteration, I used an LLM to label documents by inserting <SPLIT> markers at natural semantic boundaries.

### Original Labeling Instructions (Iteration 1)

**System Prompt:**
You are an expert document segmenter for Retrieval-Augmented Generation (RAG).
Your task: Insert <SPLIT> markers at natural semantic boundaries to divide documents into coherent, self-contained chunks optimized for downstream retrieval and generation.

Aim for an average chunk size of approximately 170 words, with an acceptable range between 100 and 270 words per chunk.

Characteristics of great chunks:
- Cohesive
- Atomic (answerable independently)
- LLM-friendly (avoids cutting mid-structure)

Tips for good split locations:
- A shift in topic or sub-topic
- A natural conclusion to a section
- A change in content type
- The introduction of a new section or heading

Guidelines:
- Prioritize semantic coherence over exact word counts
- Never insert a marker after the document's final content
- Preserve all original formatting: line breaks, spacing, punctuation, and structure

**Output:** Return ONLY the original document text with <SPLIT> markers inserted.

---

## Current Document State

**File:** ${currentFilename}

\`\`\`
${rawContent}
\`\`\`

---

## Current Statistics & Validation

**Target Range:** ${minWords}-${maxWords} words per chunk

**Overall Statistics:**
- Total Chunks: ${totalChunks}
- Average Size: ${avgSize} words
- Min Size: ${minSize} words
- Max Size: ${maxSize} words
- Invalid Chunks: ${invalidCount}

**Detailed Chunk Analysis:**

${chunkDetails.map(c => `**Chunk ${c.index}** ${c.status}
  - Word Count: ${c.wordCount}
  - Preview: "${c.preview}"`).join('\n\n')}

---

## Your Task - Iteration 2

Review the current document segmentation and provide an improved version.

You can **add**, **remove**, or **move** <SPLIT> markers to improve the segmentation. Don't feel constrained to only merge or split—sometimes a better solution is repositioning splits

### Output Format

**Step 1 - Analysis:**
Provide your reasoning for changes. For each problematic chunk, explain:
- What's wrong with the current segmentation?
- What specific change will you make and why?

**Step 2 - Revised Document:**
Return the COMPLETE document text with updated <SPLIT> markers. Make sure every <SPLIT> marker is clearly visible and the full text is included.`;

            // Copy to clipboard
            try {
                await navigator.clipboard.writeText(prompt);

                // Visual feedback
                const btn = document.getElementById('exportPromptBtn');
                const originalText = btn.textContent;
                btn.textContent = '✓ Copied!';
                btn.style.background = '#10b981';
                btn.style.color = 'white';

                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                    btn.style.color = '';
                }, 2000);
            } catch (error) {
                console.error('Error copying to clipboard:', error);
                alert('Failed to copy to clipboard. Please try again.');
            }
        }

        // Start the app
        init();
    </script>
</body>
</html>


